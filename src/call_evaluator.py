from glob import glob
from lark.visitors import Visitor_Recursive
from lark import Token
from parser import Parser
from exceptions import InvalidCommandSubstitution


class CommandSubstituitionVisitor(Visitor_Recursive):
    """
    Visits a call tree, and replaces backquoted content
    with its evaluated result.

    echo `echo foo` -> echo foo
    `echo echo` bar -> echo bar
    """

    def __init__(self, out):
        self.out = out

    def _eval_command_substituition(self, command, out):
        """
        Evaluates command substitution and returns the number of outputs
        to be taken from out. e.g.

        `echo foo` -> 1
        `echo foo; echo bar' -> 2
        """
        from commands import Seq
        from command_evaluator import extract_raw_commands

        parser = Parser()
        command_tree = parser.command_level_parse(command)
        if not command_tree:
            return
        raw_commands = extract_raw_commands(command_tree)
        seq = Seq(raw_commands)
        seq.eval(out)
        return len(raw_commands)

    def backquoted(self, tree):
        """
        If the call contains a backquote,
        we evaluate and replace the backquoted
        argument with the results in out.
        """
        no_of_outputs = self._eval_command_substituition(
            tree.children[0], self.out
            )
        if not no_of_outputs:
            raise InvalidCommandSubstitution(
                "Invalid Command Substitution: " + str(tree.children[0])
            )
        res = []
        for _ in range(no_of_outputs):  # get correct no. of outputs from out
            res.append(self.out.pop().replace("\n", " ").strip())
        res.reverse()
        # replace backquoted command with outputs
        tree.children[0] = " ".join(res)


class RedirectionVisitor(Visitor_Recursive):
    """
    Visits a redirection tree, a sub tree of a call tree,
    and extracts the IO type (< or >), and the file name.
    """

    def __init__(self):
        self.io_type = None
        self.file_name = ""

    def _extract_quoted_content(self, node):
        if len(node.children) > 0:
            self.file_name += str(node.children[0])
        else:
            self.file_name += ""

    def _double_quoted(self, tree):
        """
        extracts the string inside of double quotes
        including nested backquotes.
        """
        for child in tree.children:
            if type(child) is Token:
                self.file_name += str(child)
            else:  # backquoted
                self._extract_quoted_content(child)

    def _quoted(self, tree):
        for child in tree.children:
            if child.data == "double_quoted":
                self._double_quoted(child)
            else:  # single quoted or backquoted
                self._extract_quoted_content(child)

    def argument(self, tree):
        for child in tree.children:
            if type(child) is Token:
                self.file_name += str(child)
            else:
                self._quoted(child)

    def redirection(self, tree):
        self.io_type = str(tree.children[0])


class CallTreeVisitor(Visitor_Recursive):

    """
    Visits the nodes of a call tree generated by the lark grammar.
    extracts the application, the arguments, and file output if any.
    e.g.

    echo foo bar > file.txt -> application = echo
                               args = [foo, bar]
                               file_output = "file.txt"
    """

    def __init__(self):
        self.application = None
        self.args = []
        self.file_output = None

    def _redirection(self, tree):
        redirection_visitor = RedirectionVisitor()
        redirection_visitor.visit_topdown(tree)
        if redirection_visitor.io_type == ">":
            self.file_output = redirection_visitor.file_name
        else:
            self.args.append(redirection_visitor.file_name)

    def _extract_quoted_content(self, node):
        if len(node.children) > 0:
            return node.children[0]
        else:
            return ""

    def _double_quoted(self, tree):
        """
        extracts the string inside of double quotes
        including nested backquotes
        """
        double_quoted_args = ""
        for child in tree.children:
            if type(child) is Token:
                double_quoted_args += str(child)
            else:  # backquoted
                double_quoted_args += self._extract_quoted_content(child)
        return double_quoted_args

    def _quoted(self, tree):
        quoted_args = ""
        for child in tree.children:
            if child.data == "double_quoted":
                quoted_args += self._double_quoted(child)
            else:  # single quoted or backquoted
                quoted_args += self._extract_quoted_content(child)
        return quoted_args

    def _globbing(self, arg, unquoted_asterisk):
        if unquoted_asterisk:
            globbing = glob(arg)
            if globbing:
                self.args.append(" ".join(globbing))
                return
        self.args.append(arg)

    def _argument(self, tree):
        """
        extracts the argument from an atom, and applys
        globbing if there is an unquoted *.
        """
        unquoted_asterisk = False
        arg = ""
        for child in tree.children:
            if type(child) is Token:
                arg += str(child)
                unquoted_asterisk = "*" in str(child)
            else:
                arg += self._quoted(child)
        self._globbing(arg, unquoted_asterisk)

    def atom(self, tree):
        for child in tree.children:
            if child.data == "redirection":
                self._redirection(child)
            if child.data == "argument":
                self._argument(child)

    def _application(self, tree):
        """
        Extracts the application from the argument
        including if the application is bound by
        quotes.
        """
        application = ""
        for child in tree.children:
            if type(child) is Token:
                application += str(child)
            else:
                application += self._quoted(child)
            self.application = application

    def call(self, tree):
        for child in tree.children:
            if child.data == "argument":
                """
                an argument which is a child of a call
                will always contain the application.
                """
                self._application(child)
            elif child.data == "redirection":
                self._redirection(child)
